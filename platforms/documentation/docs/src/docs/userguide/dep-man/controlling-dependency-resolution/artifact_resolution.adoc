// Copyright (C) 2024 Gradle, Inc.
//
// Licensed under the Creative Commons Attribution-Noncommercial-ShareAlike 4.0 International License.;
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://creativecommons.org/licenses/by-nc-sa/4.0/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[artifact-resolution]]
= Artifact Resolution

After constructing a dependency graph, Gradle can perform *artifact resolution* on the resolved graph.

Gradle APIs can be used to influence the process of *artifact selection* -- the mapping of a graph to a set of artifacts.

Gradle can then expose the results of artifact selection as an `ArtifactCollection`.
More commonly, the results are exposed as a `FileCollection`, which is a flat list of files.

[[sec:artifact-selection]]
== Artifact selection

*Artifact selection* operates on the dependency graph on a node-by-node basis.
Each node in the graph may expose multiple sets of artifacts, but only one of those sets may be selected.
For example, the `runtimeElements` variant of the Java plugins exposes a `jar`, `classes`, and `resources` artifact set.
These three artifact sets represent the same distributable, but in different forms.

For each node (variant) in a graph, Gradle performs attribute matching over each set of artifacts exposed by that node to determine the best artifact set.
If no artifact sets match the requested attributes, Gradle will attempt to construct an <<artifact_transforms.adoc#artifact-transforms,artifact transform>> chain to satisfy the request.

For more details on the attribute matching process, see the <<variant_attributes.adoc#sec:attribute-matching,attribute matching>> section.

[[sec:implicit-artifact-selection]]
== Implicit artifact selection

By default, the attributes used for artifact selection are the same as those used for variant selection during graph resolution.
These attributes are specified by the link:{javadocPath}/org/gradle/api/attributes/HasAttributes.html#getAttributes()[`Configuration#getAttributes()`] property.

To perform artifact selection (and implicitly, graph resolution) using these default attributes, use the `FileCollection` and `ArtifactCollection` APIs.

NOTE: Files can also be accessed from the configuration's `ResolvedConfiguration`, `LenientConfiguration`, `ResolvedArtifact` and `ResolvedDependency` APIs.
However, these APIs are in maintenance mode and are discouraged for use in new development.
These APIs perform artifact selection using the default attributes.

=== Resolving files

To resolve files, we first define a task that accepts a `ConfigurableFileCollection` as input:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=file-resolution-task]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=file-resolution-task]"]
====

Then, we can wire up a resolvable configuration's files to the task's input.
The `Configuration` directly implements `FileCollection` and can be wired directly.
Alternatively, wiring through `Configuration#getIncoming()` is a more explicit approach:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=implicit-file-resolution]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=implicit-file-resolution]"]
====

Running both of these tasks, we can see the output is identical:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactResolution/tests/resolve-files.out[]
----

=== Resolving artifacts

Instead of consuming the files directly from the implicit artifact selection process, we can consume the artifacts, which contain both the files and the metadata.

This process is slightly more complicated, as in order to maintain Configuration Cache compatibility, we need to split the fields of `ResolvedArtifactResult` into two task inputs:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=artifact-resolution-task]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=artifact-resolution-task]"]
====

This task is initialized similarly to the file resolution task:

====
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/kotlin",files="build.gradle.kts[tags=implicit-artifact-resolution]"]
include::sample[dir="snippets/dependencyManagement/performingResolution-artifactResolution/groovy",files="build.gradle[tags=implicit-artifact-resolution]"]
====

Running this task, we can see that file metadata is included in the output:

----
include::{snippetsPath}/dependencyManagement/performingResolution-artifactResolution/tests/resolve-artifacts.out[]
----

This example demonstrates how to use an `ArtifactView` to filter and process specific types of artifacts (like Javadocs) from a dependency configuration:

====
include::sample[dir="snippets/dependencyManagement/artifactViews-simple/kotlin",files="build.gradle.kts[tags=process-javadocs-views]"]
include::sample[dir="snippets/dependencyManagement/artifactViews-simple/groovy",files="build.gradle[tags=process-javadocs-views]"]
====

In this example:

- *1. Custom Configuration*: A new configuration is created and populated with a specific dependency.
- *2. Artifact Filtering*: The task filters artifacts based on the `DocsType.JAVADOC` attribute, ensuring that only Javadoc files are selected.
- *3. Artifact Processing*: Further processing can happen here.

[[sec:customizing-artifact-selection]]
== Customizing artifact selection

An `ArtifactView` operates on top of the resolved dependency graph (i.e., `ResolutionResult`).
It queries the graph for specific artifacts, enabling artifact resolution with different attributes.

Think of a configuration's `getFiles()` output as an `ArtifactView` that uses the same attributes as the graph resolution.
However, an explicit `ArtifactView` allows you to resolve artifacts from the graph with different attributes.

There are several ways to leverage <<artifact_views.adoc#artifact-views,Artifact Views>> in Gradle:

1. **Lenient Resolution**: Using `artifactView` with `lenient=true` allows you to ignore missing dependencies.
2. **Component Filtering**: Using `artifactView` with `componentFilter` lets you exclude specific dependencies from the results.
3. **Variant Reselection**:
- Normally, an artifact must match both the graph's attributes and the `ArtifactView` attributes.
- With `withVariantReselection`, you can select artifacts from any available variants within a component.
4. **Trigger Transforms**: Trigger an `artifactTransform`.

[.text-right]
**Next Step:** <<artifact_views.adoc#artifact-views,Learn about Artifact Views>> >>
